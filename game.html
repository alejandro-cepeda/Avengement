<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Avengement ‚Äî Play (7x7 fixed)</title>
<style>
  :root{
    --bg:#071019;--cell:#0f1720;--grid-gap:6px;--ally:#66d9ff;--enemy:#ff9b6b;--boss:#ffd166;--muted:#9aa8b3;
    --move-blue: rgba(102,217,255,0.22);
    --attack-red: rgba(255,155,107,0.22);
    --valid: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system,Segoe UI Emoji;background:linear-gradient(180deg,var(--bg),#05202a);color:#e6eef3;display:flex;align-items:stretch;justify-content:space-between}
  .sidebar{width:360px;flex-shrink:0;padding:16px;background:#071522;border-right:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:12px;box-sizing:border-box;overflow-y:auto}
  .main{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:32px;gap:12px}
  h1{margin:0;font-size:18px}
  .board { display:grid; grid-template-columns:repeat(7,120px); grid-template-rows:repeat(7,120px); gap:var(--grid-gap); padding:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; box-shadow:0 8px 28px rgba(0,0,0,0.6); }
  .cell{ width:120px;height:120px;background:var(--cell);border-radius:8px;display:flex;align-items:center;justify-content:center;position:relative;user-select:none;cursor:pointer; transition:transform .08s; border:1px solid rgba(255,255,255,0.15); }
  .cell:hover{ transform:translateY(-2px) }
  .cell.occupied{ cursor:pointer }
  .piece{ width:64px;height:64px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:700;color:#041019;box-shadow:0 6px 18px rgba(0,0,0,0.6);position:relative;font-size:24px }
  .piece.ally{ background:var(--ally) }
  .piece.enemy{ background:var(--enemy) }
  .piece.boss{ background:var(--boss); width:80px;height:80px;border-radius:10px;font-size:28px }
  .piece.selected{ outline:3px solid rgba(255,255,255,0.06); transform:translateY(-6px) }
  .rest-indicator{ position:absolute; right:-6px; top:-8px; font-size:12px; background:rgba(0,0,0,0.45); padding:2px 6px; border-radius:8px; color:#fff }
  .focus-indicator{ position:absolute; left:-6px; top:-8px; font-size:12px; background:rgba(255,165,0,0.6); padding:2px 6px; border-radius:8px; color:#fff }

  .cell.move { box-shadow:0 0 0 4px var(--move-blue) inset }
  .cell.attack { box-shadow:0 0 0 4px var(--attack-red) inset }
  .cell.valid { box-shadow:0 0 0 4px var(--valid) inset }

  .panel{ background:rgba(255,255,255,0.02); padding:12px; border-radius:8px; color:var(--muted); display:flex; flex-direction:column; gap:8px }
  .muted{ color:var(--muted); font-size:13px }
  button{ background:#0b2330; border:1px solid rgba(255,255,255,0.04); color:#eaf6ff; padding:8px 12px; border-radius:8px; cursor:pointer }
  button:disabled{ opacity:0.4; cursor:not-allowed }
  .small{ padding:6px 8px; font-size:13px }
  .ability-btn{ display:block; width:100%; text-align:left; padding:8px; border-radius:8px; background:#071c2b; border:1px solid rgba(255,255,255,0.03); cursor:pointer; margin-bottom:6px }
  .ability-btn.active{ outline:2px solid rgba(102,217,255,0.12); background:linear-gradient(180deg,#092532,#071c2b) }
  input[type=number]{ width:72px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:#eaf6ff }
  .log{ background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; min-height:120px; overflow:auto; font-size:13px }
  #rightSidebar{ width:360px; flex-shrink:0; padding:16px; background:#071522; border-left:1px solid rgba(255,255,255,0.03); display:none; flex-direction:column; gap:12px; box-sizing:border-box; overflow-y:auto; }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>Avengement ‚Äî Setup & Actions</h1>

    <div class="panel" id="setupPanel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong id="setupTitle">Player 1 ‚Äî Place 3 champions</strong>
        <span id="phaseLabel" class="muted">Phase: setup</span>
      </div>
      <p class="muted" id="setupHint">Choose champion type then click tiles on your starting row to place. Once 3 placed press Finish.</p>

      <div style="display:flex;gap:8px">
        <button id="btnFighter" class="ability-btn active" data-type="fighter">‚öî Fighter ‚Äî HP 7</button>
        <button id="btnRanger" class="ability-btn" data-type="ranger">üèπ Ranger ‚Äî HP 4</button>
      </div>

      <div style="display:flex;gap:8px">
        <button id="finishBtn" class="small">Finish Player 1</button>
        <button id="resetBtn" class="small">Reset</button>
      </div>

      <hr>

      <div style="display:flex;justify-content:space-between">
        <div><strong style="color:#66d9ff">üîµ P1 HP</strong><div id="hpAlly" class="muted">‚Äî</div></div>
        <div><strong style="color:#66d9ff">AP</strong><div id="apAlly" class="muted">‚Äî</div></div>
      </div>
      <div style="display:flex;justify-content:space-between">
        <div><strong style="color:#ff9b6b">üî¥ P2 HP</strong><div id="hpEnemy" class="muted">‚Äî</div></div>
        <div><strong style="color:#ff9b6b">AP</strong><div id="apEnemy" class="muted">‚Äî</div></div>
      </div>
      <div style="border-top:1px solid rgba(255,255,255,0.1);padding-top:8px;margin-top:8px;display:flex;justify-content:space-between;align-items:center">
        <div><strong style="color:#ffd166">üêâ Dragon HP</strong><div id="hpDragon" class="muted" style="font-size:14px;font-weight:600">‚Äî</div></div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between">
        <strong>Selected</strong>
        <div class="muted" id="turnLabel">Turn: ‚Äî</div>
      </div>
      <div style="display:flex;gap:8px">
        <div style="flex:1">
          <div class="muted">Name</div>
          <div id="selName">‚Äî</div>
        </div>
        <div style="flex:1">
          <div class="muted">HP</div>
          <div id="selHP">‚Äî</div>
        </div>
      </div>

      <div id="abilityArea">
        <button id="btnMove" class="ability-btn">Move (1 AP)</button>
        <button id="btnA1" class="ability-btn">Ability 1</button>
        <button id="btnA2" class="ability-btn">Ability 2</button>
        <button id="btnA3" class="ability-btn" style="display:none">Ultimate</button>
        <button id="btnFirebreath" class="ability-btn" style="display:none">Firebreath (1 AP)</button>

        <div id="bullBox" style="margin-top:8px;display:flex;gap:8px;align-items:center;display:none">
          <input id="bullInput" type="number" min="1" max="6" value="1"/>
          <button id="bullSet" class="small">Set Bullseye</button>
          <div class="muted">Spend AP for Bullseye</div>
        </div>

        <button id="btnRest" class="ability-btn">Rest (piece rests; +1 AP & +1 HP to owner)</button>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnEndTurn" class="small">End Turn</button>
      </div>
    </div>

    <div class="panel">
      <strong>Game Log</strong>
      <div class="log" id="log"></div>
    </div>
  </aside>

  <main class="main">
    <div style="display:flex;flex-direction:column;align-items:center">
      <div class="muted">Board (7√ó7)</div>
      <div id="board" class="board" role="grid" aria-label="Game board"></div>
    </div>
  </main>

  <aside class="sidebar" id="rightSidebar">
    <h1>Game Setup</h1>
    <div class="panel" style="margin-top:8px">
      <strong>Opponent Mode</strong>
      <div style="display:flex;flex-direction:column;gap:12px;margin-top:10px">
        
        <!-- Player 1 Setup -->
        <div style="padding:10px;background:rgba(102,217,255,0.08);border-radius:6px;border-left:3px solid rgba(102,217,255,0.3)">
          <div class="muted" style="font-size:11px;margin-bottom:8px;font-weight:bold">üîµ PLAYER 1</div>
          <div style="display:flex;gap:8px">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;margin:0;flex:1">
              <input type="radio" name="p1Type" value="human" checked style="margin:0;cursor:pointer"/>
              <span class="muted" style="font-size:12px">Human</span>
            </label>
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;margin:0;flex:1">
              <input type="radio" name="p1Type" value="ai" style="margin:0;cursor:pointer"/>
              <span class="muted" style="font-size:12px">AI</span>
            </label>
          </div>
          <select id="p1Difficulty" style="width:100%;margin-top:8px;opacity:0.5;pointer-events:none;background:#333">
            <option value="easy">üèπ Easy</option>
            <option value="medium" selected>üß† Medium</option>
          </select>
        </div>

        <!-- Player 2 Setup -->
        <div style="padding:10px;background:rgba(255,155,107,0.08);border-radius:6px;border-left:3px solid rgba(255,155,107,0.3)">
          <div class="muted" style="font-size:11px;margin-bottom:8px;font-weight:bold">üî¥ PLAYER 2</div>
          <div style="display:flex;gap:8px">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;margin:0;flex:1">
              <input type="radio" name="p2Type" value="human" checked style="margin:0;cursor:pointer"/>
              <span class="muted" style="font-size:12px">Human</span>
            </label>
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;margin:0;flex:1">
              <input type="radio" name="p2Type" value="ai" style="margin:0;cursor:pointer"/>
              <span class="muted" style="font-size:12px">AI</span>
            </label>
          </div>
          <select id="p2Difficulty" style="width:100%;margin-top:8px;opacity:0.5;pointer-events:none;background:#333">
            <option value="easy">üèπ Easy</option>
            <option value="medium" selected>üß† Medium</option>
          </select>
        </div>

        <!-- AI Settings -->
        <div style="padding:8px;background:rgba(255,255,255,0.02);border-radius:6px">
          <div class="muted" style="font-size:11px;margin-bottom:6px">‚öôÔ∏è AI SETTINGS</div>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="muted" style="font-size:12px;flex:0 0 auto">Iterations:</label>
            <input id="aiIterations" type="number" value="40" min="4" max="200" style="flex:1;padding:6px;border-radius:4px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#eaf6ff"/>
          </div>
        </div>

      </div>

      <!-- Status & Start Button -->
      <div id="setupStatus" class="muted" style="margin-top:12px;font-size:12px;text-align:center;line-height:1.4;min-height:40px">
        Place pieces for both players first, then click Start
      </div>
      <button id="btnStartGame" class="small" style="width:100%;margin-top:10px;background:#0b3d0b;border:1px solid rgba(102,200,102,0.3);color:#66ff66;font-weight:bold;cursor:pointer" onclick="if(window.handleStartGameClick) window.handleStartGameClick()">‚ñ∂ Start Game</button>
    </div>

    <!-- Game State Panel (shown after Start) -->
    <div id="gameStatePanel" class="panel" style="margin-top:8px;display:none">
      <strong>Game State</strong>
      <div style="margin-top:12px;display:flex;flex-direction:column;gap:10px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <span class="muted" style="font-size:12px">Turn:</span>
          <strong id="gameTurn" style="color:#66d9ff">‚Äî</strong>
        </div>
        <div style="display:flex;justify-content:space-between;align-items:center">
          <span class="muted" style="font-size:12px">Phase:</span>
          <strong id="gamePhase" style="color:#ffd166">‚Äî</strong>
        </div>
        <div style="border-top:1px solid rgba(255,255,255,0.1);padding-top:8px;margin-top:8px">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
            <span class="muted" style="font-size:12px">üîµ P1 HP:</span>
            <strong id="gameHPAlly" style="color:#66d9ff">‚Äî</strong>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span class="muted" style="font-size:12px">üîµ P1 AP:</span>
            <strong id="gameAPAlly" style="color:#66d9ff">‚Äî</strong>
          </div>
        </div>
        <div style="border-top:1px solid rgba(255,255,255,0.1);padding-top:8px;margin-top:8px">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
            <span class="muted" style="font-size:12px">üî¥ P2 HP:</span>
            <strong id="gameHPEnemy" style="color:#ff9b6b">‚Äî</strong>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span class="muted" style="font-size:12px">üî¥ P2 AP:</span>
            <strong id="gameAPEnemy" style="color:#ff9b6b">‚Äî</strong>
          </div>
        </div>
        <div style="border-top:1px solid rgba(255,255,255,0.1);padding-top:8px;margin-top:8px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span class="muted" style="font-size:12px">üêâ Dragon HP:</span>
            <strong id="gameDragonHP" style="color:#ffd166">‚Äî</strong>
          </div>
        </div>
        <div id="aiThinking" style="display:none;margin-top:8px;padding:8px;background:rgba(102,217,255,0.1);border-radius:4px;text-align:center;color:#66d9ff;font-size:12px">
          üß† AI is thinking...
        </div>
      </div>
      <button id="btnEndGame" class="small" style="width:100%;margin-top:12px;background:#3d0b0b;border:1px solid rgba(200,102,102,0.3);color:#ff9999">‚èπ End Game</button>
    </div>
      <div class="panel">
        <div id="cardAbilities" style="font-size:13px;color:var(--muted);line-height:1.6">
          <div style="margin-bottom:8px"><strong>Abilities:</strong></div>
          <div id="cardAbilityList">No piece selected</div>
        </div>
      </div>
      <div id="strengthPrompt" class="panel" style="display:none">
        <div style="margin-bottom:8px"><strong style="color:#66d9ff">Strength Available!</strong></div>
        <div class="muted" style="margin-bottom:8px;font-size:12px">Use Strength to displace the struck enemy to an adjacent square? (1 AP)</div>
        <div style="display:flex;gap:8px">
          <button id="btnStrengthYes" class="small" style="flex:1;background:#092532">Yes (1 AP)</button>
          <button id="btnStrengthNo" class="small" style="flex:1;background:#2a0000">No</button>
        </div>
      </div>
      <div id="revivalPrompt" class="panel" style="display:none">
        <div style="margin-bottom:8px"><strong style="color:#66d9ff">Revival Available!</strong></div>
        <div class="muted" style="margin-bottom:8px;font-size:12px">You crossed a threshold upward! Choose a removed champion to revive on your starting row.</div>
        <div id="revivalChoices" style="display:flex;flex-direction:column;gap:6px"></div>
      </div>
      <div id="thresholdRemovalPrompt" class="panel" style="display:none">
        <div style="margin-bottom:8px"><strong style="color:#ff6b6b">Piece Elimination!</strong></div>
        <div class="muted" style="margin-bottom:8px;font-size:12px">You fell below a health threshold! Click on a highlighted piece to eliminate it.</div>
        <div id="thresholdRemovalStatus" style="display:flex;flex-direction:column;gap:6px"></div>
      </div>
      <div id="gameOverPrompt" class="panel" style="display:none;background:#1a0f1a;border:2px solid #ff6b6b">
        <div style="margin-bottom:8px"><strong style="color:#ff6b6b;font-size:16px">Game Over!</strong></div>
        <div id="gameOverMessage" class="muted" style="margin-bottom:12px;font-size:12px"></div>
        <div style="display:flex;gap:8px;flex-direction:column">
          <button id="btnPlayAgain" class="small" style="width:100%;background:#092532">Play Again</button>
          <button id="btnMainMenu" class="small" style="width:100%;background:#2a0000">Main Menu</button>
        </div>
      </div>
    </div>
  </aside>

<script src="scripts/game/champion.js"></script>
<script src="scripts/game/champions/fighter.js"></script>
<script src="scripts/game/champions/ranger.js"></script>
<script src="scripts/game/champions/bossDragon.js"></script>
<script src="scripts/game/utils.js"></script>
<script src="scripts/game/app.js"></script>
<script src="scripts/ui/aiManager.js"></script>
<!-- <script src="scripts/ui/gameStateManager.js"></script> -->
<script>
// Reset game state - called when End Game button is clicked
window.resetGame = function(){
  const finishBtn = document.getElementById('finishBtn');
  const resetBtn = document.getElementById('resetBtn');
  if(finishBtn) finishBtn.style.display = 'block';
  if(resetBtn) resetBtn.style.display = 'block';
  if(resetBtn) resetBtn.click();
  if(window.updateSetupStatus) window.updateSetupStatus();
}
</script>
<script>
// Monte-Carlo Tree Search (MCTS) AI with proper UCB1 algorithm for exploration/exploitation balance
(() => {
  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  // MCTS Node class: tracks visits and value sum for UCB1 calculation with RAVE support
  class MCTSNode {
    constructor(action = null, parent = null, stateHash = null) {
      this.action = action;           // the action that led to this node
      this.parent = parent;            // parent node for backpropagation
      this.children = [];              // child nodes for each possible action
      this.visits = 0;                 // number of times this node was visited
      this.valueSum = 0;               // sum of all playout scores from this node
      this.isFullyExpanded = false;    // all children have been generated
      this.untriedActions = [];        // actions that haven't been explored yet
      this.stateHash = stateHash;      // hash of board state for transposition table
      // RAVE (Rapid Action Value Estimation) tracking
      this.raveVisits = 0;             // visits where action appeared in playout
      this.raveValueSum = 0;           // sum of scores from those playouts
    }

    // Get RAVE value estimate
    getRaveValue() {
      return this.raveVisits === 0 ? 0 : this.raveValueSum / this.raveVisits;
    }

    // Blend regular value with RAVE value using beta function
    getBlendedValue() {
      const visits = Math.max(1, this.visits);
      const raveVisits = Math.max(1, this.raveVisits);
      // Beta function: more weight on RAVE early (few visits), more on regular value later
      const weight = 1 / (1 + visits / (3 * raveVisits));  // 3x scaling factor
      
      const regularValue = visits === 0 ? 0 : this.valueSum / visits;
      const raveValue = this.getRaveValue();
      return (1 - weight) * regularValue + weight * raveValue;
    }

    // Upper Confidence Bound (UCB1) for balancing exploration vs exploitation
    ucb1(c = Math.sqrt(2)) {
      if (this.visits === 0) return Infinity; // unvisited nodes have highest priority
      const exploitation = this.getBlendedValue();  // Use blended RAVE+regular value
      const exploration = c * Math.sqrt(Math.log(this.parent.visits) / this.visits);
      return exploitation + exploration;
    }

    // Select best child using UCB1
    selectBestChild() {
      let best = null;
      let bestUcb = -Infinity;
      for (const child of this.children) {
        const ucb = child.ucb1();
        if (ucb > bestUcb) {
          bestUcb = ucb;
          best = child;
        }
      }
      return best;
    }

    // Average value from this node
    getAverageValue() {
      return this.visits === 0 ? 0 : this.valueSum / this.visits;
    }

    // Get max number of children (progressive widening)
    getMaxChildren() {
      // Early: only explore 2-4 actions, gradually expand to 12
      return Math.min(2 + Math.floor(this.visits / 8), 12);
    }
  }

  function scoreStateForActor(state, actor){
    const opponent = actor === 'ally' ? 'enemy' : 'ally';
    const myPieces = Object.values(state.pieces).filter(p=>p.player===actor);
    const oppPieces = Object.values(state.pieces).filter(p=>p.player===opponent);
    const myPieceCount = myPieces.length;
    const oppPieceCount = oppPieces.length;
    
    const myTotalHp = myPieces.reduce((sum,p)=>(sum + (p.currentHp||0)), 0);
    const oppTotalHp = oppPieces.reduce((sum,p)=>(sum + (p.currentHp||0)), 0);
    
    // Primary objective: piece count difference (most important)
    const pieceDiff = myPieceCount - oppPieceCount;
    
    // Secondary: total health difference (relative advantage)
    const healthDiff = myTotalHp - oppTotalHp;
    
    // NEW: Mobility factor - pieces with more movement options are stronger
    let avgMyMobility = 0;
    if (myPieceCount > 0) {
      const totalMobility = myPieces.reduce((sum, p) => {
        const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        const moveOptions = dirs.filter(([dr,dc]) => {
          const nr = p.r + dr, nc = p.c + dc;
          return nr >= 0 && nr < 7 && nc >= 0 && nc < 7 && state.grid[nr][nc] === null;
        }).length;
        return sum + moveOptions;
      }, 0);
      avgMyMobility = totalMobility / myPieceCount;
    }
    
    let avgOppMobility = 0;
    if (oppPieceCount > 0) {
      const totalMobility = oppPieces.reduce((sum, p) => {
        const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        const moveOptions = dirs.filter(([dr,dc]) => {
          const nr = p.r + dr, nc = p.c + dc;
          return nr >= 0 && nr < 7 && nc >= 0 && nc < 7 && state.grid[nr][nc] === null;
        }).length;
        return sum + moveOptions;
      }, 0);
      avgOppMobility = totalMobility / oppPieceCount;
    }
    const mobilityDiff = avgMyMobility - avgOppMobility;
    
    // NEW: Centering bonus - pieces near center more flexible
    const getDistFromCenter = (r, c) => Math.sqrt((r - 3) ** 2 + (c - 3) ** 2);
    const myCenterBonus = myPieces.reduce((sum, p) => sum - getDistFromCenter(p.r, p.c), 0);
    const oppCenterBonus = oppPieces.reduce((sum, p) => sum - getDistFromCenter(p.r, p.c), 0);
    const centerDiff = myCenterBonus - oppCenterBonus;
    
    // Scoring formula: emphasize piece elimination, health, mobility, and positioning
    const score = 
      pieceDiff * 1000 +              // piece elimination is paramount (1000x weight)
      healthDiff * 10 +               // health advantage matters (10x weight)
      mobilityDiff * 5 +              // movement options are valuable (5x weight)
      centerDiff * 2 +                // board control via centering (2x weight)
      (myPieceCount > 0 ? 50 : -10000) +  // massive penalty for losing all pieces
      (oppPieceCount === 0 ? 10000 : 0);  // huge bonus for eliminating all enemy pieces
    
    return score;
  }

  function applyActionToState(state, action){
    // Mutate the passed state snapshot
    if(action.type === 'move'){
      const p = state.pieces[action.pieceId]; if(!p) return;
      state.grid[p.r][p.c] = null; p.r = action.to.r; p.c = action.to.c; state.grid[p.r][p.c] = p.id;
      if(p.player && p.player !== 'boss' && state.player && state.player[p.player]) state.player[p.player].ap = Math.max(0, state.player[p.player].ap - 1);
      return;
    }
    if(action.type === 'strike'){
      const attacker = state.pieces[action.attacker]; const target = state.pieces[action.target]; if(!attacker || !target) return;
      if(attacker.player && attacker.player !== 'boss' && state.player && state.player[attacker.player]) state.player[attacker.player].ap = Math.max(0, state.player[attacker.player].ap - 1);
      target.currentHp = (target.currentHp || target.maxHp) - 2;
      if(target.player !== 'boss' && state.player && state.player[target.player]) state.player[target.player].hpCurrent = Math.max(0, state.player[target.player].hpCurrent - 2);
      // Optional displacement in simulation
      if(action.displaceTo && state.pieces[target.id]){
        const dr = action.displaceTo.r, dc = action.displaceTo.c;
        if(dr>=0 && dr<state.grid.length && dc>=0 && dc<state.grid[0].length && state.grid[dr][dc] === null){ state.grid[target.r][target.c] = null; target.r = dr; target.c = dc; state.grid[dr][dc] = target.id; }
      }
      if(target.currentHp <= 0){ // remove piece
        state.grid[target.r][target.c] = null; delete state.pieces[target.id]; state.setupPlaced[target.player] = state.setupPlaced[target.player].filter(x=>x!==target.id);
      }
      return;
    }
    if(action.type === 'quick'){
      const attacker = state.pieces[action.attacker]; const target = state.pieces[action.target]; if(!attacker || !target) return;
      if(attacker.player && attacker.player !== 'boss' && state.player && state.player[attacker.player]) state.player[attacker.player].ap = Math.max(0, state.player[attacker.player].ap - 1);
      target.currentHp = (target.currentHp || target.maxHp) - 1;
      if(target.player !== 'boss' && state.player && state.player[target.player]) state.player[target.player].hpCurrent = Math.max(0, state.player[target.player].hpCurrent - 1);
      if(target.currentHp <= 0){ state.grid[target.r][target.c] = null; delete state.pieces[target.id]; state.setupPlaced[target.player] = state.setupPlaced[target.player].filter(x=>x!==target.id); }
      return;
    }
    if(action.type === 'rest'){
      const p = state.pieces[action.pieceId]; if(!p) return; // apply rest rewards immediately for simplicity
      if(state.player && state.player[p.player]){
        state.player[p.player].ap = Math.min(6, (state.player[p.player].ap||0) + 1);
        state.player[p.player].hpCurrent = Math.min(state.player[p.player].hpTotal||0, (state.player[p.player].hpCurrent||0) + 1);
      }
      return;
    }
    if(action.type === 'bullseye'){
      const attacker = state.pieces[action.attacker]; const target = state.pieces[action.target]; if(!attacker || !target) return; 
      const spend = Math.max(1, Math.min(action.spend||1, (state.player && state.player[attacker.player] && state.player[attacker.player].ap) || 0)); 
      if(attacker.player && attacker.player !== 'boss' && state.player && state.player[attacker.player]) state.player[attacker.player].ap = Math.max(0, (state.player[attacker.player]&&state.player[attacker.player].ap) - spend); 
      target.currentHp = (target.currentHp || target.maxHp) - (2 * spend); 
      if(target.player !== 'boss' && state.player && state.player[target.player]) state.player[target.player].hpCurrent = Math.max(0, state.player[target.player].hpCurrent - (2 * spend)); 
      if(target.currentHp <= 0){ state.grid[target.r][target.c] = null; delete state.pieces[target.id]; state.setupPlaced[target.player] = state.setupPlaced[target.player].filter(x=>x!==target.id); } 
      return; 
    }
    if(action.type === 'lunging'){
      const attacker = state.pieces[action.attacker]; if(!attacker) return; if(state.player && state.player[attacker.player]) state.player[attacker.player].ap = Math.max(0, state.player[attacker.player].ap - 3);
      // Hit adjacent for 2 dmg
      const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
      const adj = [];
      for(const d of dirs){ const nr=attacker.r+d[0], nc=attacker.c+d[1]; if(nr>=0 && nr<state.grid.length && nc>=0 && nc<state.grid[0].length && state.grid[nr][nc]) adj.push(state.grid[nr][nc]); }
      adj.forEach(tid=>{ const tgt = state.pieces[tid]; if(tgt){ tgt.currentHp = (tgt.currentHp||tgt.maxHp) - 2; if(tgt.player !== 'boss' && state.player && state.player[tgt.player]) state.player[tgt.player].hpCurrent = Math.max(0, state.player[tgt.player].hpCurrent - 2); } });
      // Optionally displace surviving targets to a random adjacent empty tile
      for(const tid of adj){ const tgt = state.pieces[tid]; if(tgt && tgt.currentHp > 0){ const empties = []; for(const d of dirs){ const tr = tgt.r + d[0], tc = tgt.c + d[1]; if(tr>=0 && tr<state.grid.length && tc>=0 && tc<state.grid[0].length && state.grid[tr][tc] === null) empties.push({r:tr,c:tc}); } if(empties.length>0){ const choice = empties[Math.floor(Math.random()*empties.length)]; state.grid[tgt.r][tgt.c] = null; tgt.r = choice.r; tgt.c = choice.c; state.grid[choice.r][choice.c] = tgt.id; } }
      }
      // Allow up to 3 random adjacent moves for attacker
      for(let m=0;m<3;m++){ const empties = []; for(const d of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]){ const nr=attacker.r+d[0], nc=attacker.c+d[1]; if(nr>=0 && nr<state.grid.length && nc>=0 && nc<state.grid[0].length && state.grid[nr][nc] === null) empties.push({r:nr,c:nc}); } if(empties.length===0) break; const ch = empties[Math.floor(Math.random()*empties.length)]; state.grid[attacker.r][attacker.c] = null; attacker.r = ch.r; attacker.c = ch.c; state.grid[ch.r][ch.c] = attacker.id; }
      return;
    }
    if(action.type === 'endTurn'){
      // Simplified: rotate actor order ally->boss->enemy->boss; if boss, simulate boss action immediately
      if(state.currentActor === 'ally') state.currentActor = 'boss';
      else if(state.currentActor === 'boss') state.currentActor = 'enemy';
      else if(state.currentActor === 'enemy') state.currentActor = 'boss';
      // If we moved into boss, process a sampled boss action
      if(state.currentActor === 'boss'){
        // sample d6
        const v = Math.floor(Math.random()*6)+1;
        if(v >=1 && v <=4){
          // move by direction mapping
          const map = {1:[-1,0],2:[0,1],3:[0,-1],4:[1,0]};
          const [dr,dc] = map[v];
          const boss = state.pieces[state.dragonId];
          if(boss){
            let finalR = boss.r, finalC = boss.c; let moved=0;
            for(let step=0; step<3; step++){ let nr = finalR+dr, nc = finalC+dc; if(nr<0||nr>=state.grid.length||nc<0||nc>=state.grid[0].length){ break; } finalR=nr; finalC=nc; moved++; }
            if(moved>0){ const targetId = state.grid[finalR][finalC]; if(targetId && state.pieces[targetId] && targetId !== state.dragonId){ // displace target: remove from grid only
              const tgt = state.pieces[targetId]; state.grid[tgt.r][tgt.c] = null; // the player will place it; simulate a penalty: 3 damage
              tgt.currentHp = (tgt.currentHp||tgt.maxHp) - 3; if(tgt.player !== 'boss' && state.player && state.player[tgt.player]) state.player[tgt.player].hpCurrent = Math.max(0, state.player[tgt.player].hpCurrent - 3); if(tgt.currentHp<=0){ delete state.pieces[targetId]; state.setupPlaced[tgt.player]=state.setupPlaced[tgt.player].filter(x=>x!==targetId); }
              }
              // move boss
              state.grid[boss.r][boss.c] = null; boss.r = finalR; boss.c = finalC; state.grid[boss.r][boss.c] = boss.id;
            }
          }
        } else if(v === 5){ const boss = state.pieces[state.dragonId]; if(boss) boss.currentHp = Math.min(boss.maxHp, (boss.currentHp||boss.maxHp) + 3); }
        else { // firebreath 6
          const boss = state.pieces[state.dragonId]; if(boss){ const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]; dirs.forEach(d=>{ const nr=boss.r+d[0], nc=boss.c+d[1]; if(nr>=0&&nr<state.grid.length&&nc>=0&&nc<state.grid[0].length){ const tid=state.grid[nr][nc]; if(tid && state.pieces[tid] && state.pieces[tid].player !== 'boss'){ state.pieces[tid].currentHp = (state.pieces[tid].currentHp||state.pieces[tid].maxHp)-3; if(state.player && state.player[state.pieces[tid].player]) state.player[state.pieces[tid].player].hpCurrent = Math.max(0, state.player[state.pieces[tid].player].hpCurrent - 3); if(state.pieces[tid].currentHp<=0){ delete state.pieces[tid]; state.grid[nr][nc]=null; state.setupPlaced[ state.pieces[tid]?.player ] = (state.setupPlaced[ state.pieces[tid]?.player ] || []).filter(x=>x!==tid); } } } }); }
        }
        // advance from boss
        state.currentActor = (state.currentActor === 'boss') ? 'enemy' : state.currentActor;
      }
      return;
    }
  }

  // Global AI configuration (set when "Start Game" is clicked)
  let gameConfig = {
    p1IsAI: false,
    p1Difficulty: 'medium',
    p2IsAI: false,
    p2Difficulty: 'medium',
    iterations: 40
  };

  // Simple zobrist-style hash for transposition table
  function hashBoardState(state) {
    let hash = 0;
    for (const id in state.pieces) {
      const p = state.pieces[id];
      hash = ((hash << 5) - hash) + (p.r * 7 + p.c);
      hash = hash & hash; // Convert to 32-bit int
    }
    return hash >>> 0; // Ensure positive
  }

  // Alpha-beta style fast evaluation: skip obviously bad moves
  function getFastEvaluation(actions, actor, state) {
    if (actions.length <= 2) return actions;  // Keep small sets
    
    const scored = actions.map(a => {
      let badnessScore = 0;
      const testState = deepClone(state);
      applyActionToState(testState, a);
      
      // Penalty: loses a piece for free
      const pieceLoss = Object.values(state.pieces).filter(p => p.player === actor).length -
                        Object.values(testState.pieces).filter(p => p.player === actor).length;
      if (pieceLoss > 0) badnessScore += pieceLoss * 100;
      
      // Bonus: eliminates enemy
      const enemyLoss = Object.values(state.pieces).filter(p => p.player !== actor && p.player !== 'boss').length -
                        Object.values(testState.pieces).filter(p => p.player !== actor && p.player !== 'boss').length;
      badnessScore -= enemyLoss * 150;
      
      return { action: a, score: badnessScore };
    });
    
    // Sort by goodness, keep top 60% (minimum 2)
    scored.sort((a, b) => a.score - b.score);
    const keepCount = Math.max(2, Math.ceil(actions.length * 0.6));
    return scored.slice(0, keepCount).map(s => s.action);
  }

  // Proper MCTS playout: random but with preference for offensive moves
  // Evaluates state OBJECTIVELY from perspective of initial actor
  function playoutFromState(state, evaluateForActor, maxDepth = 12) {
    let depth = 0;
    const s = deepClone(state);
    let currentActor = state.currentActor;
    
    while(depth < maxDepth){
      const allyCount = Object.values(s.pieces).filter(p=>p.player==='ally').length;
      const enemyCount = Object.values(s.pieces).filter(p=>p.player==='enemy').length;
      
      // Terminal condition: one side eliminated
      if(allyCount===0 || enemyCount===0) break;
      
      const actions = window.GameAPI.enumerateActionsForState(s, currentActor);
      if(!actions || actions.length===0) break;
      
      // Bias towards offensive actions: 60% attack, 40% other
      const attackActions = actions.filter(a => ['strike','quick','bullseye','lunging'].includes(a.type));
      const otherActions = actions.filter(a => !['strike','quick','bullseye','lunging'].includes(a.type));
      
      let selectedAction;
      if(attackActions.length > 0 && Math.random() < 0.6){
        // Prefer attacks that target enemies
        selectedAction = attackActions[Math.floor(Math.random() * attackActions.length)];
      } else if(otherActions.length > 0){
        selectedAction = otherActions[Math.floor(Math.random() * otherActions.length)];
      } else {
        selectedAction = actions[Math.floor(Math.random() * actions.length)];
      }
      
      applyActionToState(s, selectedAction);
      currentActor = s.currentActor; // advance to next actor
      depth++;
    }
    
    // Score from perspective of evaluateForActor (not whose turn it is)
    return scoreStateForActor(s, evaluateForActor);
  }

  // MCTS Tree Search: builds tree of promising actions with proper UCB1 selection
  // Includes progressive widening, killer moves, RAVE, transposition table, and alpha-beta pruning
  async function monteCarloTreeSearch(rootState, actor, timeLimit = 1000, maxIterations = 100) {
    const root = new MCTSNode(null, null, hashBoardState(rootState));
    root.parent = root; // root's parent is itself for backprop termination
    root.visits = 0; // will be incremented during backprop
    
    // Transposition table for caching node evaluations
    const transpositionTable = new Map();
    
    // Killer moves: depth -> [good moves found at this depth]
    const killerMoves = {};
    let depthTracker = new Map();  // node -> depth from root
    depthTracker.set(root, 0);
    
    const startTime = Date.now();
    let iteration = 0;
    
    while(iteration < maxIterations && (Date.now() - startTime) < timeLimit) {
      let node = root;
      const s = deepClone(rootState);
      let currentActor = rootState.currentActor || actor;
      let depth = 0;
      
      // SELECTION: traverse tree using UCB1 until we find a non-terminal node
      while(node.children.length > 0 && node.isFullyExpanded){
        node = node.selectBestChild();
        applyActionToState(s, node.action);
        currentActor = s.currentActor;
        depth++;
        depthTracker.set(node, depth);
      }
      
      // EXPANSION: add a new child node if we haven't explored all actions
      let childNode = node;
      if(!node.isFullyExpanded){
        // Generate legal actions for this state
        if(node.untriedActions.length === 0){
          let actions = window.GameAPI.enumerateActionsForState(s, currentActor) || [];
          // Alpha-beta pruning: filter out obviously bad moves
          if (actions.length > 8) {
            actions = getFastEvaluation(actions, currentActor, s);
          }
          node.untriedActions = actions;
        }
        
        // Progressive widening: only expand up to getMaxChildren() children
        if(node.children.length < node.getMaxChildren() && node.untriedActions.length > 0){
          const idx = Math.floor(Math.random() * node.untriedActions.length);
          const action = node.untriedActions.splice(idx, 1)[0];
          
          // Mark node as fully expanded if we've reached max children capacity
          if(node.children.length >= node.getMaxChildren() - 1 && node.untriedActions.length === 0){
            node.isFullyExpanded = true;
          }
          
          // Create and add child node
          childNode = new MCTSNode(action, node, hashBoardState(s));
          node.children.push(childNode);
          depthTracker.set(childNode, depth + 1);
          
          // Apply action to state for playout
          applyActionToState(s, action);
          
          // Track this move as killer move at this depth
          if (!killerMoves[depth]) killerMoves[depth] = [];
          // Will add to killers after backprop if it scores well
        } else if(node.untriedActions.length === 0) {
          node.isFullyExpanded = true;
        }
      }
      
      // SIMULATION: run random playout from this position
      const score = playoutFromState(s, actor);
      
      // BACKPROPAGATION: update all ancestors with result and RAVE statistics
      let current = childNode;
      let backpropDepth = depth;
      while(current.parent !== current){ // stop when parent is self (root)
        current.visits++;
        current.valueSum += score;
        
        // Update RAVE statistics: this action appeared in a playout
        if (current.action) {
          current.raveVisits++;
          current.raveValueSum += score;
        }
        
        // Track killer moves: if this move scored well, remember it
        if (score > 0) {
          if (!killerMoves[backpropDepth]) killerMoves[backpropDepth] = [];
          // Keep only unique killer moves (by type and targets)
          const actionKey = `${current.action.type}-${current.action.attacker || current.action.pieceId}-${current.action.target || ''}`;
          if (!killerMoves[backpropDepth].some(a => {
            const key = `${a.type}-${a.attacker || a.pieceId}-${a.target || ''}`;
            return key === actionKey;
          })) {
            killerMoves[backpropDepth].push(current.action);
            // Keep max 3 killer moves per depth
            if (killerMoves[backpropDepth].length > 3) {
              killerMoves[backpropDepth].shift();
            }
          }
        }
        
        current = current.parent;
        backpropDepth--;
      }
      // Update root as well
      current.visits++;
      current.valueSum += score;
      
      iteration++;
      
      // Yield control to prevent blocking
      await new Promise(r => setTimeout(r, 0));
    }
    
    // Return the best action: balance between visited (explored) and valuable (high average)
    // Use robust child (most visited) since it's more statistically reliable
    let best = null;
    let bestScore = -Infinity;
    for(const child of root.children){
      // Combine visit count (exploration) with blended value (RAVE+regular) (exploitation)
      const visits = Math.max(1, child.visits);
      const blendedValue = child.getBlendedValue();
      const robustnessScore = visits + blendedValue * 10; // 10x weight for value
      
      if(robustnessScore > bestScore){
        bestScore = robustnessScore;
        best = child.action;
      }
    }
    return best;
  }

  // Easy AI: simple ranger-focused strategy
  async function findBestActionEasy(iterations, actor){
    const root = window.GameAPI.snapshot();
    if(!root.currentActor) root.currentActor = actor;
    if(root.currentActor === 'boss') return null;
    
    const actions = window.GameAPI.enumerateActionsForState(root, actor) || [];
    if(actions.length === 0) return null;

    // Helper to get the piece doing the action
    const getPiece = (a) => {
      let id = a.attacker || a.pieceId;
      return root.pieces && root.pieces[id];
    };

    // Filter for ranger-originating actions
    const rangerActions = actions.filter(a => {
      const p = getPiece(a);
      return p && p.champion === 'ranger';
    });

    if(rangerActions.length === 0){
      // No ranger actions available, pick random action
      return actions[Math.floor(Math.random() * actions.length)];
    }

    // Prioritize bullseye actions
    const bullActions = rangerActions.filter(a => a.type === 'bullseye');
    const ap = (root.player && root.player[actor] && root.player[actor].ap) || 0;

    if(bullActions.length > 0){
      // Filter for affordable bullseye
      const affordable = bullActions.filter(a => !a.spend || a.spend <= ap);
      const candidates = affordable.length > 0 ? affordable : bullActions;
      
      // Pick bullseye targeting nearest enemy
      let best = null;
      let bestDist = Infinity;
      for(const a of candidates){
        const attacker = getPiece(a);
        const target = root.pieces[a.target];
        if(attacker && target){
          const dist = Math.abs(attacker.r - target.r) + Math.abs(attacker.c - target.c);
          if(dist < bestDist){
            bestDist = dist;
            best = a;
          }
        }
      }
      if(best) return best;
    }

    // Otherwise, pick ranger strike/quick targeting nearest enemy
    const strikeActions = rangerActions.filter(a => ['strike','quick'].includes(a.type));
    if(strikeActions.length > 0){
      let best = null;
      let bestDist = Infinity;
      for(const a of strikeActions){
        const attacker = getPiece(a);
        const target = root.pieces[a.target];
        if(attacker && target){
          const dist = Math.abs(attacker.r - target.r) + Math.abs(attacker.c - target.c);
          if(dist < bestDist){
            bestDist = dist;
            best = a;
          }
        }
      }
      if(best) return best;
    }

    // Move rangers closer to enemies
    const moveActions = rangerActions.filter(a => a.type === 'move');
    if(moveActions.length > 0){
      const enemies = Object.values(root.pieces).filter(p => p.player !== actor && p.player !== 'boss');
      let best = null;
      let bestImprovement = -Infinity;
      
      for(const a of moveActions){
        const ranger = root.pieces[a.pieceId];
        if(!ranger) continue;
        
        let minBefore = Infinity;
        for(const e of enemies){
          const d = Math.abs(ranger.r - e.r) + Math.abs(ranger.c - e.c);
          minBefore = Math.min(minBefore, d);
        }
        
        let minAfter = Infinity;
        for(const e of enemies){
          const d = Math.abs(a.to.r - e.r) + Math.abs(a.to.c - e.c);
          minAfter = Math.min(minAfter, d);
        }
        
        const improvement = minBefore - minAfter;
        if(improvement > bestImprovement){
          bestImprovement = improvement;
          best = a;
        }
      }
      if(best) return best;
    }

    // Default: return any ranger action
    return rangerActions[Math.floor(Math.random() * rangerActions.length)];
  }

  // Adaptive time management based on game state
  function calculateAdaptiveTimeLimit(baseIterations, gameState, actor) {
    const opponent = actor === 'ally' ? 'enemy' : 'ally';
    const myPieces = Object.values(gameState.pieces).filter(p => p.player === actor).length;
    const oppPieces = Object.values(gameState.pieces).filter(p => p.player === opponent).length;
    
    // Endgame (1-2 pieces): use more time (clearer, fewer decisions, more critical)
    if (myPieces <= 2) {
      return Math.max(2000, baseIterations * 100);  // 4-5 seconds, more iterations
    }
    
    // Late game (exactly 2-3 pieces on both sides): moderate time
    if (myPieces === 2 && oppPieces === 2) {
      return baseIterations * 70;  // ~3.5 seconds
    }
    
    // Early game (all pieces present): less time (game tree is huge)
    if (myPieces >= 3 && oppPieces >= 3) {
      return baseIterations * 40;  // ~2 seconds, faster play
    }
    
    // Default mid-game
    return baseIterations * 50;  // ~2.5 seconds
  }

  // Main difficulty selection function
  async function findBestActionForDifficulty(iterations, actor, difficulty){
    if(difficulty === 'easy'){
      return await findBestActionEasy(iterations, actor);
    }
    // Medium/default: use MCTS with adaptive time limit
    const gameState = window.GameAPI.snapshot();
    const timeLimit = calculateAdaptiveTimeLimit(iterations, gameState, actor);
    return await monteCarloTreeSearch({...gameState}, actor, timeLimit, iterations);
  }

  // Build HTML fragment (no <html> wrapper) for inserting into modal
  function buildBoardFragment(parsed){
    try{
      const ROWS = parsed.grid ? parsed.grid.length : 7;
      const COLS = parsed.grid ? parsed.grid[0].length : 7;
      const piecesMap = {};
      if(parsed.p && Array.isArray(parsed.p)){
        parsed.p.forEach(arr=>{ piecesMap[arr[0]] = { id:arr[0], player:arr[1], champion:arr[2], r:arr[3], c:arr[4], currentHp:arr[5] }; });
      } else if(parsed.pieces){ for(const id in parsed.pieces){ piecesMap[id] = parsed.pieces[id]; } }

      let html = '';
      html += `<h2 style="margin:0 0 8px 0">Example Board State</h2>`;
      html += `<div style="display:flex;gap:12px;align-items:flex-start">`;
      html += `<div class="modal-board" style="flex:0 0 auto">`;
      html += `<div class="board" style="display:grid;grid-template-columns:repeat(${COLS},36px);grid-auto-rows:36px;gap:6px">`;

      const grid = (parsed.grid && parsed.grid.map(r=>r.slice())) || Array.from({length:ROWS}, ()=>Array(COLS).fill(null));
      for(const id  in piecesMap){ const p = piecesMap[id]; if(p && Number.isFinite(p.r) && Number.isFinite(p.c)) grid[p.r][p.c] = id; }
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const pid = grid[r][c];
          if(pid && piecesMap[pid]){
            const p = piecesMap[pid];
            const cls = p.player === 'ally' ? 'ally' : (p.player === 'enemy' ? 'enemy' : 'boss');
            const symbol = p.champion === 'ranger' ? 'üèπ' : (p.champion === 'fighter' ? '‚öî' : (p.champion === 'dragon' ? 'üêâ' : (p.champion||'‚óº')));
            html += `<div style="width:36px;height:36px;background:#0f1720;border-radius:6px;display:flex;align-items:center;justify-content:center"><div style="font-size:14px">${symbol}</div></div>`;
          } else {
            html += `<div style="width:36px;height:36px;background:rgba(255,255,255,0.01);border-radius:6px"></div>`;
          }
        }
      }
      html += `</div>`; // board
      html += `</div>`; // modal-board

      html += `<div style="flex:1;min-width:260px">`;
      html += `<div style="font-size:13px;color:#9aa8b3;margin-bottom:8px">Actor: ${parsed.actor || parsed.currentActor || '-'} ‚Äî Players: A(AP:${parsed.players?.ally?.ap||0},HP:${parsed.players?.ally?.hp||parsed.players?.ally?.hpCurrent||0}) | E(AP:${parsed.players?.enemy?.ap||0},HP:${parsed.players?.enemy?.hp||parsed.players?.enemy?.hpCurrent||0})</div>`;
      html += `<div style="background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;max-height:320px;overflow:auto"><strong>Pieces</strong><ul style="margin:8px 0 0 14px;padding:0;line-height:1.4;color:#e6eef3">`;
      for(const id in piecesMap){ const p = piecesMap[id]; html += `<li style="margin-bottom:6px">${id} ‚Äî ${p.champion||p.name||'-'} ‚Äî ${p.player} ‚Äî at (${p.r},${p.c}) ‚Äî HP: ${p.currentHp||p.hp||'-'}</li>`; }
      html += `</ul></div>`;
      html += `</div>`; // right col
      html += `</div>`; // flex
      return html;
    }catch(e){ return `<pre>Error rendering state: ${e.message}</pre>`; }
  }

  // Show modal overlay containing the parsed board state
  function showStateModal(parsed){
    try{
      // create overlay
      const overlay = document.createElement('div'); overlay.style.position='fixed'; overlay.style.left='0'; overlay.style.top='0'; overlay.style.right='0'; overlay.style.bottom='0'; overlay.style.background='rgba(0,0,0,0.6)'; overlay.style.zIndex='9999'; overlay.style.display='flex'; overlay.style.alignItems='center'; overlay.style.justifyContent='center';
      const modal = document.createElement('div'); modal.style.width='820px'; modal.style.maxWidth='calc(100% - 40px)'; modal.style.maxHeight='calc(100% - 40px)'; modal.style.background='#071019'; modal.style.border='1px solid rgba(255,255,255,0.04)'; modal.style.padding='14px'; modal.style.borderRadius='10px'; modal.style.boxShadow='0 12px 48px rgba(0,0,0,0.7)'; modal.style.color='#e6eef3'; modal.style.overflow='auto';
      // header
      const header = document.createElement('div'); header.style.display='flex'; header.style.justifyContent='space-between'; header.style.alignItems='center'; header.style.marginBottom='8px';
      const title = document.createElement('div'); title.innerHTML = `<strong>Example Board State</strong>`; header.appendChild(title);
      const controls = document.createElement('div'); controls.style.display='flex'; controls.style.gap='8px';
      const btnExport = document.createElement('button'); btnExport.className='small'; btnExport.textContent='Export JSON';
      btnExport.addEventListener('click', ()=>{ const data = JSON.stringify(parsed, null, 2); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'av_state.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });
      const btnClose = document.createElement('button'); btnClose.className='small'; btnClose.textContent='Close'; btnClose.addEventListener('click', ()=>{ overlay.remove(); });
      controls.appendChild(btnExport); controls.appendChild(btnClose); header.appendChild(controls);

      modal.appendChild(header);
      const body = document.createElement('div'); body.innerHTML = buildBoardFragment(parsed);
      modal.appendChild(body);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    }catch(e){ alert('Failed to open modal: '+e.message); console.warn(e); }
  }

  // Export the MCTS AI functions for use by aiManager.js
  window.findBestActionForDifficulty = findBestActionForDifficulty;
})();
</script>
</body>
</html>
